# 类加载过程
## 加载的流程
- 类的生命周期为： 加载=》验证 =》准备 =》解析 =》初始化 =》使用 =》卸载
- JAVA的JVM类加载过程： 加载=》连接（验证 =》准备 =》解析） =》初始化

***类的加载、验证、准备、初始化的开始顺序是依次进行的，这些步骤开始之后的过程可能会有重叠。 而解析过程会发生在初始化过程中。***

## 类加载中"初始化"开始的时机
### 类初始化
 >  JVM规范中只定义了类加载过程中初始化过程开始的时机，加载、连接过程都应该在初始化之前开始(解析除外)，这些过程具体在何时开始，JVM规范并没有定义，不同的虚拟机可以根据具体的需求自定义。
- 1. 程序运行的时候遇到如以下指令，如果类没初始化，即要进行初始化：new 、getstatic、putstatic、invokestatic 等
   - 通过new对象
   - 通过读取、设置一个静态成员变量（不包括final声明的）
   - 调用一个类的静态成员函数
 - 2. 使用反射调用的时候，类没有初始化即初始化
 - 3. 当一个类初始化的时候，父类没初始化，先初始化父类再初始化本类。
 - 4. 当虚拟机启动时。虚拟机会首先初始化带有main方法的类，即主类

***主动引用才会初始化类，被动引用不会初始化 。***

### 接口初始化
> 接口和类都需要初始化，接口和类的初始化过程基本一样，不同点在于：类初始化时，如果发现父类尚未被初始化，则先要初始化父类，然后再初始化自己；但接口初始化时，并不要求父接口已经全部初始化，只有程序在运行过程中用到当父接口中的东西时才初始化父接口。

## 各个流程的情况
### 加载
#### 类加载
***要满足初始化时机 并类没加载 才进行加载***
- 通过类的限定名来获取类的二进制字节流，即class文件。
- 将二进制字节流转化为特定数据结构，存储在方法区中。
- 在内存中创建class类型对象，通过这个对象提供外界访问这个类的接口。

#### 数组加载
当程序在运行过程中遇到new关键字创建一个数组时，由JVM直接创建数组类，再由类加载器创建数组中的元素类。

而普通类的加载由类加载器完成。既可以使用系统提供的引导类加载器，也可以使用用户自定义的类加载器。

###  验证
***JVM虚拟机可接受任意来源的二进制字节流 ，为了安全需要验证***
- 文件格式验证（验证输入的二进制字节流是否符合class文件结构的规范）
- 元数据验证 （对方法区中的字节码描述信息进行语义分析，确保其符合Java语法规范）
- 字节码验证  （本阶段对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。）
- 符号引用验证（发生在解析阶段）

### 准备
- 为已经在方法区中的类中的静态成员变量分配内存
- 为静态变量初始化值0，null 、false

### 解析
- 符号引用转为直接引用

### 初始化
***执行类构造器clinit()的过程，clinit()由编译器产生，收集类中static{}静态代码块中的类变量赋值语句和 类中静态成员变量赋值 。 在准备阶段，类中静态成员变量已经完成了默认初始化，而在初始化阶段，clinit()方法对静态成员变量进行显示初始化。***


## 类加载器

### 类与类加载器
- 类加载器的作用：将class文件加载进JVM的方法区，并在方法区中创建一个java.lang.Class对象作为外界访问这个类的接口。
- 类与类加载器的关系：比较两个类是否相等，只有当这两个类由同一个加载器加载才有意义；否则，即使同一个class文件被不同的类加载器加载，那这两个类必定不同，即通过类的Class对象的equals执行的结果必为false。

### JVM类加载器种类
- 启动类加载器
- 扩展类加载器
- 应用程序类加载器

## 双亲委派模型
- 工作过程：如果一个类加载器收到了加载类的请求，它首先将请求交由父类加载器加载；若父类加载器加载失败，当前类加载器才会自己加载类。
- 作用：像java.lang.Object这些存放在rt.jar中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的Object类都是同一个。
- 原理：双亲委派模型的代码在java.lang.ClassLoader类中的loadClass函数中实现，其逻辑如下：
   - 首先检查类是否被加载；
   - 若未加载，则调用父类加载器的loadClass方法；
   - 若该方法抛出ClassNotFoundException异常，则表示父类加载器无法加载，则当前类加载器调用findClass加载类；
   - 若父类加载器可以加载，则直接返回Class对象；
 